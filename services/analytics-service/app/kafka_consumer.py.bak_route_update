from __future__ import annotations

import os
import json
from datetime import datetime, timezone
from aiokafka import AIOKafkaConsumer

from app.db import SessionLocal
from app.models import ShipmentState, RouteStats, StatusBucket

KAFKA_BROKERS = os.getenv("KAFKA_BROKERS", "127.0.0.1:9092")
TOPIC_CREATED = os.getenv("KAFKA_TOPIC_SHIPMENT_CREATED", "shipment.created")
TOPIC_STATUS_CHANGED = os.getenv("KAFKA_TOPIC_SHIPMENT_STATUS_CHANGED", "shipment.status_changed")
GROUP = os.getenv("KAFKA_CONSUMER_GROUP", "analytics-service")


def _now_utc_naive():
    return datetime.now(timezone.utc).replace(tzinfo=None)


async def run_consumer(stop_event):
    consumer = AIOKafkaConsumer(
        TOPIC_CREATED,
        TOPIC_STATUS_CHANGED,
        bootstrap_servers=KAFKA_BROKERS,
        group_id=GROUP,
        enable_auto_commit=True,
        auto_offset_reset="earliest",
    )
    await consumer.start()
    try:
        async for msg in consumer:
            if stop_event.is_set():
                break

            raw = msg.value.decode("utf-8", errors="replace")
            try:
                payload = json.loads(raw)
            except Exception:
                continue

            if msg.topic == TOPIC_CREATED:
                _handle_created(payload)
            elif msg.topic == TOPIC_STATUS_CHANGED:
                _handle_status_changed(payload)
    finally:
        await consumer.stop()


def _handle_created(payload: dict):
    shipment_id = int(payload["id"])
    origin = payload.get("origin")
    destination = payload.get("destination")
    status = str(payload.get("status", "CREATED")).upper()
    now = _now_utc_naive()

    db = SessionLocal()
    try:
        s = db.get(ShipmentState, shipment_id)
        if s is None:
            s = ShipmentState(
                shipment_id=shipment_id,
                origin=origin,
                destination=destination,
                assigned_to=None,
                last_status=status,
                last_ts=now,
                created_ts=now,
            )
            db.add(s)
        else:
            s.origin = origin or s.origin
            s.destination = destination or s.destination
            s.last_status = status
            s.last_ts = now
            if s.created_ts is None:
                s.created_ts = now
        db.commit()
    finally:
        db.close()


def _handle_status_changed(payload: dict):
    shipment_id = int(payload["shipment_id"])
    status = str(payload.get("status", "")).upper()
    origin = payload.get("origin")
    destination = payload.get("destination")
    assigned_to = payload.get("assigned_to", None)

    ts_str = payload.get("timestamp")
    try:
        ts = datetime.fromisoformat(ts_str.replace("Z", "+00:00")).astimezone(timezone.utc).replace(tzinfo=None) if ts_str else _now_utc_naive()
    except Exception:
        ts = _now_utc_naive()

    db = SessionLocal()
    try:
        s = db.get(ShipmentState, shipment_id)
        if s is None:
            s = ShipmentState(
                shipment_id=shipment_id,
                origin=origin,
                destination=destination,
                assigned_to=int(assigned_to) if assigned_to is not None else None,
                last_status=status or "CREATED",
                last_ts=ts,
                created_ts=None,
            )
            db.add(s)
        else:
            s.last_status = status or s.last_status
            s.last_ts = ts
            s.origin = origin or s.origin
            s.destination = destination or s.destination
            if assigned_to is not None:
                try:
                    s.assigned_to = int(assigned_to)
                except Exception:
                    pass
        db.commit()
    finally:
        db.close()

